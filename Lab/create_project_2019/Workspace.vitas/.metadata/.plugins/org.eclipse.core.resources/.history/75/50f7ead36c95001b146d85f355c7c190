/**
 *  Test program for flexible GPIO
 */

#include <stdio.h>
#include <stdlib.h>
#include <xparameters.h>
#include <xscugic.h>
#include <xil_exception.h>
#include <sleep.h>
//#include "Gpio.h"
#include "ScuGic.h"

using namespace Hardware;

struct MyIp {
  // existing registers
   uint32_t pdor;   // Port data output register
   uint32_t pdir; 	// For expansion
   uint32_t pddr;   // Port data direction register
   uint32_t psor; 	// For expansion
   uint32_t pcor; 	// For expansion
   uint32_t ptor; 	// For expansion

   // this might cause issues later because not sure how many bits are read
//   uint32_t unused; // For enabling the interrupt, // 0 represent false, 1 represent true
//   uint32_t ack;	// For interrupt configuration in IP
   // uint32_t irq_pin;
   // //uint32_t sensitivity; // control if rising, falling or either

};

static MyIp * const myIP = reinterpret_cast<MyIp *>(XPAR_MYGPIO2_0_S00_AXI_BASEADDR);

void handler(void *data) {
//  	myIP->int_en = 0x0; // 0 represent false, 1 represent true

	static int count = 0;
	printf("button clicked %d\n", count++);

  	// Clear flag in your IP
	// myIP->int_en = 0x1;
    // myIP->ack = 0xFFFF;
	myIP->pdor = 0x1111;
	sleep(2);
}

ScuGic *scuGic;

void testGpioInterrupts() {
   scuGic = new ScuGic(XPAR_PS7_SCUGIC_0_DEVICE_ID);

   // this part connects the interrupt handler with the scuGic
   scuGic->connectHandler(XPAR_FABRIC_MYGPIO2_0_IRQ_INTR, handler, nullptr, Priority_Normal);

	// setting the first 4 bits to be outputs (LEDs)
   //	myIP->int_en = 0x1111;
   	myIP->pddr= 0b1111; // 1 for output. 0 for input
	myIP->pdor = 0b1111;
//	myIP->ack = 0x0000;
   // Code to configure interrupts in your IP

	Xil_ExceptionEnable();

   // Wait for events
	int count = 0;
	for(;;) {
		// let LED incrementally
	   count +=2;
	   myIP->pdor = count + 2;
	   if (count > 15) count = 0;
	   printf("pdir %d\n", myIP->pdir)
	   usleep(200000);
   }
}

int main() {
   printf("Starting\n");

   testGpioInterrupts();

   return 0;
}
